\section{Why?}

I wrote {\PROD} because I needed  new training material to teach
grad students about Prolog programming. Why was that so? Well, to
begin with,   I think the training given to most programmers
emphases one particular {\em paradigm of computer systems}. I
wanted to broaden that training. Also, as a software engineering
educator, I needed to {\em show software systems} in my classes.
Finally, despite all its flaws, {\em Prolog is  a very useful
language} and I found myself using techniques not found in the
standard Prolog texts.

Not convinced? Well, then I see I'll have to explain myself a
little more...


\begin{figure*}
{\footnotesize
\begin{center}
\begin{tabular}{|p{6in}|}\hline
 Textbooks:
 \bi
 \item
{\em The classic}: Clocksin \& Mellish, Programming in Prolog 4th
ed. Springer-Verlag 1994.

\item {\em The best seller:} Ivan Bratko, Prolog Programming for
Artificial, Addison-Wesley. At the time of this writing, the third
edition was out.

\item {\em For the theoreticians:} Hogger, C. J., Introduction to
Logic Programming Academic Press 1984.

\item {\em Contains lots of cookbook solutions:} Sterling and
Shapiro, The Art of Prolog. MIT Press, Cambridge, Mass. 1986.

\item {\em Advanced Prolog programming (and small!)}: Clause and
Effect: Prolog Programming for the Working Programmer By William
F.Clocksin, Springer Verlag 1997. ISBN: 3540629718

\item {\em Prolog \& General AI}: Computational Intelligence: A
Logical Approach: D. Poole and A. Mackworth and R. Goebel,
 Oxford University Press, 1998.


\ei\\\hline

On-line material (there's a lot out there; here is just a sample):
\bi \item {\em Newsgroups}: \protect\url{news://comp.lang.prolog}
is a friendly place to post queries, but be warned. Many students
post queries like ``HELP: my assignment is due and I don't know
how to reverse a list. What can I do?''. And, sometimes, the
locals at \protect\url{news://comp.lang.prolog} express (mild)
annoyance at this sort of behavior \item {\em The Prolog FAQ}:
\protect\url{http://flits102-126.flits.rug.nl/~dirk-jan/prolog/faq/html/}
\item {\em Code Libraries}: \bi \item Dick Botting's Prolog
collection:
\protect\url{http://www.csci.csusb.edu/cs320/prolog/index.html}.
The Techniques section is especially recommended. \item David
Poole's code library from the Computational Intelligence book:
\protect\url{http://www.cs.ubc.ca/spider/poole/ci/ci_code.html}.
\item The CMU Prolog repository:
\protect\url{http://www-2.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/lang/prolog/0.html}
\ei\ei
\\\hline
 Tutorials:
\bi \item {\em Nice}:
\protect\url{http://www.csupomona.edu/~jrfisher/www/prolog_tutorial/contents.html}
\item {\em Fun, but a little basic:}
\protect\url{http://burks.bton.ac.uk/burks/language/prolog/amzi/index.htm}
\item {\em Very nice:}
\protect\url{http://ktiml.mff.cuni.cz/~bartak/prolog/index.html}
\ei
\\\hline \end{tabular} \end{center}}\caption{Prolog
resources.}\label{fig:prologresources}
\end{figure*}



\subsection{Paradigms of computer systems}

Computer development systems can be divided up according to what
they are trying to do. Systems based on ``C'' are usually
optimized to {\em run} fast. Systems based on some normalized
database design are optimized to be {\em maintained} quickly. And
systems written in high-level languages are usually the ones where
programs can be {\em written} quickly.

This characterization of systems into ``fast to run'' or ``fast to
maintain'' or ``fast to write'' is, of course, only an
approximation. Clearly, these kinds of systems can be combined so
that (e.g.) systems written in high-level languages can be quickly
written then compiled to ``C'' so they run fast. Nevertheless, the
emphasis in most programming courses is on procedural programs in
languages such as ``C'' programming. This has the side-effect that
most programmers never see how much of their work is influenced by
the ``fast to run'' approach. As standard desktop machines get
faster, it becomes practical to move beyond the ``fast to run''
paradigm.

System development for systems that are fast to maintain has been
discussed extensively elsewhere~\cite{date95}. Here, we focus on
systems written in high-level languages that are quick to write.


\subsection{Must show software}

Erwin Schroedinger once said {\em if you cannot- in the long run-
tell everyone what you have been doing, your doing has been
worthless.} Well, it took me a while to work it out but finally I
realized that as a software engineering educator, I should be
presenting software to my classes. Every class, lots of software.

I've tried various languages and various formats and this is my latest attempt. In
this experiment, the new  mix is:



 \bi \item

The programming language is
Prolog~\cite{der96,me89zb,bratko01,ok90,sterling94}) since, for me
anyway,  it lets me show the most functionality in the fewest lines.

\item

The examples are biased towards logic-for- software-
engineering\ldots

\item

\dots coded up in a programming style not discussed extensively in
the standard Prolog texts {\ldots}

\item {\ldots} presented in a very hands-on programming style. \ei

Also, I can't convince anyone that Prolog is pretty good without
pretty good documentation. {\PROD} is a bunch of {\LaTeX} tricks that
let me rapidly generate camera-ready documents from my Prolog code.

Maybe you'll
find it useful as a programming or teaching resource.


\subsection{But why are you still using Prolog?}

Well, it's like this. As long as:

\bi


\item

I want to write state-of-the-art model-based software.

\item

I can keep up with the next generation of grad student programmers.

\item

I don't have unlimited programming time.

\item

There is a large international community of educators, researchers and vendors
supplying high quality Prolog materials.

\ei

\noindent
then, I'll stay with Prolog.  Here's my reasons:

Prolog endures. It is an old language (1972) yet it keeps being
taught, keeps being used industrially,  and high-quality textbooks
and interpreters are readily available
(see~\fig{prologresources}). Nevertheless, like many folk, I used
Prolog in grad school then left it behind for something better.
``Prolog?'', I used to say, ``that was something we used to do as
kids''.

Only
thing was, the ``something better'' wasn't so much better. After nearly a decade  of real-world
commercial programming in Prolog, then Lisp, then Smalltalk, I realized
that my best logic programming code was smaller than my best functional or OO code.
This was a surprise since I thought that (e.g.) OO would allow me to better structure my programs. (Actually, I stopped thinking that when I discovered the wonderfully messy and practical Perl programming language.
Heck, my Prolog has to be at least as well structured as the average Perl program.)


Anyway, then I became an academic again and I noticed a couple of things. Firstly,
the machines were getting faster. It is now perfectly viable to deliver interpreted systems in a commercial setting
(look at all the Perl code out there).

While the machines get faster, I seem to be getting slower. I kept finding that I
didn't have time to write huge programs.
I had to return to my Prolog in order to get certain jobs done.

Slow as I was, I found that I could still out-program my
grad students.
See, I'd thrash around for a weekend
in Prolog and then give it to them saying ``code it in C, make it faster,
make it better''. Trouble was, months later, they were still fighting their way through memory
leaks, pointer problems, etc.

Another reason for staying with Prolog is that,
at least in my view,  logic programming techniques are being used more and more.
For example, the reflection pattern proposed by OO design gurus (and implemented as e.g.
Java beans or aspect-oriented programming)
is just programmers realizing that things like {\tt clause/2} is astonishingly useful. But this is
just a special case of my next point.

Old-fashioned software is like obsessed over-trained athlete
sprinting for the finish line. Such software runs fast since it
doesn't look where it is going. But, it  will stumble and crash at
the first  hole in the road. Modern model-based software builds
and reflects over some model carefully crafted at runtime. Choices
are recognized, and processed  via an on-going  analysis of the
internal model. Prolog is just  terrific for implementing such
reflection- 20 lines of meta-interpretation can give you so very
much.

Q.E.D.

collect frquency counts on how often rules fire

change the conflict resolution mechansim:
currently, change does not update the id #. should it?

the rule id should be autogenerated based on the seed symbol
'ruleIdName'

need a checker for bad values (hint: build used and set tables)
need a new type: pointer to another thing

want a test engine that tries it out on random bags, assesses
the results

add a keyword "say" to the rules
rule Id for Group if If then Then say Say
where Say is a spy command that writes an explanation
text to the screen

e,g, 
rule r0
for  check_order
if   

rule b1
for  check_order
if   order=I with items has  potatoChips and  
     not (order=I with items has N and
          grocery with name=N  with type(bottle))
then order=I  with items << pepsi
say  ['adding pepsi to order ',I].


then(check_order, b1, vars(A, B)) :-
	order(P, Q),
	o(id(A), order(P, Q), R),
	o(items<<pepsi, R, S),
	o(change, S, T),
	printl(['adding pepsi to order',P],'').

printl([],_).
printl([H|T],Sep) :- 
        write(Sep),
        write(H),
        printl(T,' ').

the specificity measure is silly. want to really count
the conjunctions- in the ifs.

countC((X,Y),N) :- !,
		countC(X,N1),
		countC(Y,N2),
		N is N1 + N2.
countC(\+ X,N) :- !,
	       countC(X,N).
countC(_,1).

at an at keyword that explictly sets the specificity
of a rule

want demon rules that fire in any context
hint: try giving a variable name to the for entry and see
what happens.

there is a bug in the or expansion. find it. fix it.
(hint: repeated rule names)

rewrite the rules such that when something is bagged,
it is popped off the order list. 

do the above, but this time redefine the dd.pl entries
such that in 1 line of rule code, stuff is popped off
the order and thrown into a bag

often cleaner to carry a local bag of stuff. 
adda keyword to the definition of a class "assert"
which if present, we do get as done now. otherwise.
it "gets" it from a list carried around by the rule interpreter.
